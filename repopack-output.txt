This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-13T17:25:25.082Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
includes/
  bitboards.h
  evaluate.h
  generate.h
  move.h
  parse.h
  perft.h
  piece_square_value.h
  position.h
  score.h
  search.h
  types.h
  uci.h
src/
  evaluate/
    endgame.c
    evaluate.c
    game_phase.c
    pawn_structure.c
    piece_square_value.c
    rook.c
  search/
    search.c
  bitboards.c
  generate.c
  main.c
  move.c
  parse.c
  perft.c
  position.c
  uci.c
Makefile

================================================================
Repository Files
================================================================

================
File: includes/bitboards.h
================
#ifndef BITBOARDS_H
#define BITBOARDS_H

#include "move.h"
#include "position.h"

#define SET_BIT(bb, square) ((bb) |= (1ULL << (square)))
#define CLEAR_BIT(bb, square) ((bb) &= ~(1ULL << (square)))
#define GET_BIT(bb, square) ((bb) & (1ULL << (square)))

static inline int get_lsb(uint64_t bb)
{
	if (bb == 0) return -1;
	return __builtin_ctzll(bb);
}

void init_bitboards(struct position *pos);
void verify_board_state(const struct position *pos);
void update_bitboards_with_move(struct move move, struct position *pos);

#endif

================
File: includes/evaluate.h
================
#ifndef EVALUATE_H
#define EVALUATE_H

#include "position.h"

/* the evaluation function tries to determine the value of the current       */
/* position for the current player. the greater the value, the better the    */
/* position is for the current player. our basic implementation just sums    */
/* the value of all pieces on the board. knights are worth more than pawns,  */
/* rooks are worth more than knights, and so on. the evaluation function is  */
/* very important, because all moves the engine makes are based on the value */
/* assigned to them by this function. you will find some common improvements */
/* listed below, but you are strongly encouraged to come up with your own    */
/* ideas. if you need some inspiration, play a game of chess and take a look */
/* at one of the positions. who's winning? and, why? this function returns   */
/* a positive value when the current player is winning, and a negative value */
/* when the opponent is winning.                                             */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: piece square tables                                 */
/* improve the evaluation to also take into account the position of pieces   */
/* on the board. for example, knights can reach more squares from the center */
/* of the board, and pawns are more valuable when they are close to          */
/* promoting. you can also vary this depending on the phase of the game. for */
/* example, at the start of the game, the king wants to castle and hide in a */
/* corner behind the other pieces, but when there are few other pieces left  */
/* the king should become more active.                                       */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: common patterns                                     */
/* pawns like to be connected in chains so they can defend each other. rooks */
/* like to be placed on open files, and bishops like to be placed on open    */
/* diagonals. other common patterns include pins, forks, and batteries. add  */
/* some logic to your evaluation function to detect these patterns and       */
/* change the value of the position accordingly.                             */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: mobility score                                      */
/* the mobility score is a measure of how many moves a player can make. if a */
/* player has many possible moves, they probably have a strong position.     */
/*                                                                           */
/* https://www.chessprogramming.org/Evaluation                               */
/* https://www.chessprogramming.org/Piece-Square_Tables                      */
/* https://www.chessprogramming.org/Mobility
 * */

#define MAX(a,b) ((a) > (b) ? (a) : (b))

int evaluate(const struct position *pos);
float get_game_phase(const struct position *pos);
int evaluate_pawn_structure(const struct position *pos);
int evaluate_rook(const struct position *pos);
int get_piece_square_value(int piece, int square, float phase_pct);
int evaluate_king_corner_endgame(const struct position *pos, float game_phase);

// Material Value
extern const int piece_value[6];

#endif

================
File: includes/generate.h
================
#ifndef GENERATE_H
#define GENERATE_H

#include "move.h"
#include "position.h"

#include <stddef.h>

/* maximum number of moves in any chess position. the actual maximum number  */
/* of moves seems to be 218, but just to be safe we round up to the nearest  */
/* power of two. the `moves` parameter of `generate_psuedo_legal_moves` and  */
/* `generate_legal_moves` should be an array of size `MAX_MOVES`.            */
#define MAX_MOVES 256

/* generate all pseudo-legal moves and store them in `moves`, which must be  */
/* large enough to hold all pseudo-legal moves in the position. pseudo-legal */
/* moves include moves that leave the king in check, or castling through a   */
/* square that is controlled by an opponent piece. returns the number of     */
/* pseudo-legal moves generated.                                             */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: staged or chunked move generation                   */
/* some moves such as captures and pawn promotions are likely to have a      */
/* bigger impact on the game than quiet moves. instead of wasting time       */
/* generating (and sorting) all moves, provide a way to generate important   */
/* moves separately. this is especially useful for alpha-beta pruning.       */
/*                                                                           */
/* https://www.chessprogramming.org/Move_Generation                          */
/* https://www.chessprogramming.org/Pseudo-Legal_Move                        */
size_t generate_pseudo_legal_moves(const struct position *pos, struct move *moves);

/* generate all legal moves and store them in `moves`, which must be large   */
/* enough to hold all legal moves in the position. returns the number of     */
/* legal moves generated.                                                    */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: getting out of check                                */
/* in some positions, such as when in check, the number of legal moves is    */
/* much smaller than the number of pseudo-legal moves. instead of generating */
/* all pseudo-legal moves, write a generator specifically for moves that get */
/* out of check.                                                             */
/*                                                                           */
/* https://www.chessprogramming.org/Check                                    */
/* https://www.chessprogramming.org/Double_Check                             */
size_t generate_legal_moves(const struct position *pos, struct move *moves);

#endif

================
File: includes/move.h
================
#ifndef MOVE_H
#define MOVE_H

#include "position.h"

/* this struct represents a chess move.                                      */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: compact encoding                                    */
/* this struct currently has three integers. a more efficient implementation */
/* might use just a single integer, using bitwise operations to encode and   */
/* decode the move.                                                          */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: extended move structure                             */
/* when making (or sorting) moves, you may need some additional information  */
/* such as the piece that is moving, or the piece that is being captured.    */
/* while these can easily be looked up from the position, the move generator */
/* already did that, and it would be faster not to have to look it up again. */
/* the move generator could encode this extra information in the move        */
/* instead, saving other parts of the code from having to redo the lookups.  */
/*                                                                           */
/* https://www.chessprogramming.org/Encoding_Moves                           */
struct move {
	/* the square the piece is moving from.                                  */
	int from_square;

	/* the square the piece is moving to.                                    */
	int to_square;

	/* the type of piece that is being promoted to, if any.                  */
	int promotion_type;
};

/* create a move from the given parameters.                                  */
struct move make_move(int from_square, int to_square, int promotion_type);

/* parse a move and store the result in `move`. valid moves are the from     */
/* square, followed by the to square, optionally followed by the promotion   */
/* type. examples: e2e4, b1c3, e7d8q, and e1g1. returns `SUCCESS` on         */
/* success, `FAILURE` on failure.                                            */
int parse_move(struct move *move, const char *string);

/* make a move on the position. the move must be pseudo-legal for the given  */
/* position.                                                                 */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: undo move                                           */
/* when searching for the best move in a position, you will often need to    */
/* make a move, examine the resulting position, and then go back to the      */
/* previous position. instead of making a copy of the whole position, it is  */
/* faster to go back to the previous position by undoing the move. the piece */
/* movement itself can easily be undone my moving the piece back from the to */
/* square to the from square. other information, such as the captured piece, */
/* castling rights, and en passant square still need to be copied. also,     */
/* don't forget to unpromote your pawns!                                     */
/*                                                                           */
/* https://www.chessprogramming.org/Make_Move                                */
void do_move(struct position *pos, struct move move);

/* check if a move is legal for the given position. the move must already be */
/* known to be pseudo-legal.                                                 */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: legality test                                       */
/* for simplicity, to check if a move is legal, we generate all pseudo-legal */
/* moves for the opponent and check if any of them can capture the king.     */
/* this is inefficient, and duplicates work that will also be done by the    */
/* search function. one way to improve this is to instead look from the king */
/* to the opponent pieces. this way we don't have to generate all opponent   */
/* moves.                                                                    */
/*                                                                           */
/* https://www.chessprogramming.org/Legal_Move                               */
int is_legal(const struct position *pos, struct move move);

#endif

================
File: includes/parse.h
================
#ifndef PARSE_H
#define PARSE_H

/* parse a file. valid files are 'a', 'b', 'c', 'd', 'e', 'f', 'g', and 'h'. */
/* returns the file on success, `NO_FILE` on failure.                        */
int parse_file(char c);

/* parse a rank. valid ranks are '1', '2', '3', '4', '5', '6', '7', and '8'. */
/* returns the rank on success, `NO_RANK` on failure.                        */
int parse_rank(char c);

/* parse a square. valid squares are a file followed by a rank. trailing     */
/* characters are ignored. returns the square on success, `NO_SQUARE` on     */
/* failure.                                                                  */
int parse_square(const char *string);

/* parse a color. valid colors are 'w' and 'b'. returns the color on         */
/* success, `NO_COLOR` on failure.                                           */
int parse_color(char c);

/* parse a type. valid types are 'p', 'n', 'b', 'r', 'q', and 'k'. returns   */
/* the type on success, `NO_TYPE` on failure.                                */
int parse_type(char c);

/* parse a piece. valid pieces are 'P', 'p', 'N', 'n', 'B', 'b', 'R', 'r',   */
/* 'Q', 'q', 'K', and 'k'. uppercase letters are for white pieces, lowercase */
/* letters are for black pieces. returns the piece on success, `NO_PIECE` on */
/* failure.                                                                  */
int parse_piece(char c);

#endif

================
File: includes/perft.h
================
#ifndef PERFT_H
#define PERFT_H

/* PERFormance Testing is a way to test the performance and correctness of   */
/* the move generator. it works by counting the number of positions that can */
/* be reached after a number of moves, and comparing it to a known value.    */
/*                                                                           */
/* it is recommended to run perft every time you make changes to the move    */
/* generator.                                                                */
/*                                                                           */
/* https://www.chessprogramming.org/Perft                                    */
void perft_run(void);

#endif

================
File: includes/piece_square_value.h
================
#ifndef PIECE_SQUARE_VALUE_H
#define PIECE_SQUARE_VALUE_H

const int pawn_position_start[64] = {
	0,  0,  0,  0,  0,  0,  0,  0,
   50, 50, 50, 50, 50, 50, 50, 50,
   10, 10, 20, 30, 30, 20, 10, 10,
	5,  5, 10, 25, 25, 10,  5,  5,
	0,  0,  0, 20, 20,  0,  0,  0,
	5, -5,-10,  0,  0,-10, -5,  5,
	5, 10, 10,-20,-20, 10, 10,  5,
	0,  0,  0,  0,  0,  0,  0,  0
};

const int pawn_position_end[64] = {
	0,  0,  0,  0,  0,  0,  0,  0,
	50, 50, 50, 50, 50, 50, 50, 50,
	40, 40, 40, 40, 40, 40, 40, 40,
	30, 30, 30, 30, 30, 30, 30, 30,
	20, 20, 20, 20, 20, 20, 20, 20,
	10, 10, 10, 10, 10, 10, 10, 10,
	10, 10, 10, 10, 10, 10, 10, 10,
	0,  0,  0,  0,  0,  0,  0,  0
};

const int bishop_position_start[64] = {
	-20,-10,-10,-10,-10,-10,-10,-20,
	-10,  0,  0,  0,  0,  0,  0,-10,
	-10,  0,  5, 10, 10,  5,  0,-10,
	-10,  5,  5, 10, 10,  5,  5,-10,
	-10,  0, 10, 10, 10, 10,  0,-10,
	-10, 10, 10, 10, 10, 10, 10,-10,
	-10, 10,  0,  0,  0,  0, 10,-10,
	-20,-10,-10,-10,-10,-10,-10,-20,
};

const int bishop_position_end[64] = {
	-20,-10,-10,-10,-10,-10,-10,-20,
	-10,  0,  0,  0,  0,  0,  0,-10,
	-10,  0,  5, 10, 10,  5,  0,-10,
	-10,  5,  5, 10, 10,  5,  5,-10,
	-10,  0, 10, 10, 10, 10,  0,-10,
	-10, 10, 10, 10, 10, 10, 10,-10,
	-10, 10,  0,  0,  0,  0, 10,-10,
	-20,-10,-10,-10,-10,-10,-10,-20,
};

const int knight_position_start[64] = {
	-50,-40,-30,-30,-30,-30,-40,-50,
	-40,-20,  0,  0,  0,  0,-20,-40,
	-30,  0, 10, 15, 15, 10,  0,-30,
	-30,  5, 15, 20, 20, 15,  5,-30,
	-30,  0, 15, 20, 20, 15,  0,-30,
	-30,  5, 10, 15, 15, 10,  5,-30,
	-40,-20,  0,  5,  5,  0,-20,-40,
	-50,-40,-30,-30,-30,-30,-40,-50,
};

const int knight_position_end[64] = {
	-50,-40,-30,-30,-30,-30,-40,-50,
	-40,-20,  0,  0,  0,  0,-20,-40,
	-30,  0, 10, 15, 15, 10,  0,-30,
	-30,  5, 15, 20, 20, 15,  5,-30,
	-30,  0, 15, 20, 20, 15,  0,-30,
	-30,  5, 10, 15, 15, 10,  5,-30,
	-40,-20,  0,  5,  5,  0,-20,-40,
	-50,-40,-30,-30,-30,-30,-40,-50,
};

const int rook_position_start[64] = {
	0,  0,  0,  0,  0,  0,  0,  0,
	5, 10, 10, 10, 10, 10, 10,  5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
	0,  0,  0,  5,  5,  0,  0,  0
};

const int rook_position_end[64] = {
	0,  0,  0,  0,  0,  0,  0,  0,
	5, 10, 10, 10, 10, 10, 10,  5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
   -5,  0,  0,  0,  0,  0,  0, -5,
	0,  0,  0,  5,  5,  0,  0, 0
};

const int queen_position_start[64] = {
	-20,-10,-10, -5, -5,-10,-10,-20,
	-10,  0,  0,  0,  0,  0,  0,-10,
	-10,  0,  5,  5,  5,  5,  0,-10,
	-5,  0,  5,  5,  5,  5,  0, -5,
	 0,  0,  5,  5,  5,  5,  0, -5,
	-10,  5,  5,  5,  5,  5,  0,-10,
	-10,  0,  5,  0,  0,  0,  0,-10,
	-20,-10,-10, -5, -5,-10,-10,-20
};

const int queen_position_end[64] = {
	-20,-10,-10, -5, -5,-10,-10,-20,
	-10,  0,  0,  0,  0,  0,  0,-10,
	-10,  0,  5,  5,  5,  5,  0,-10,
	-5,  0,  5,  5,  5,  5,  0, -5,
	 0,  0,  5,  5,  5,  5,  0, -5,
	-10,  5,  5,  5,  5,  5,  0,-10,
	-10,  0,  5,  0,  0,  0,  0,-10,
	-20,-10,-10, -5, -5,-10,-10,-20
};

const int king_position_start[64] = {
	-30,-40,-40,-50,-50,-40,-40,-30,
	-30,-40,-40,-50,-50,-40,-40,-30,
	-30,-40,-40,-50,-50,-40,-40,-30,
	-30,-40,-40,-50,-50,-40,-40,-30,
	-20,-30,-30,-40,-40,-30,-30,-20,
	-10,-20,-20,-20,-20,-20,-20,-10,
	 10, 25,  0,  0,  0,  0, 25, 10,
};

const int king_position_end[64] = {
	-50,-40,-30,-20,-20,-30,-40,-50,
	-30,-20,-10,  0,  0,-10,-20,-30,
	-30,-10, 20, 30, 30, 20,-10,-30,
	-30,-10, 30, 40, 40, 30,-10,-30,
	-30,-10, 30, 40, 40, 30,-10,-30,
	-30,-10, 20, 30, 30, 20,-10,-30,
	-30,-30,  0,  0,  0,  0,-30,-30,
	-50,-30,-30,-30,-30,-30,-30,-50
};

#endif

================
File: includes/position.h
================
#ifndef POSITION_H
#define POSITION_H

#include <stdio.h>
#include "types.h"

/* this struct represents the placement of pieces on a chess board, as well  */
/* as any additional information such as side to move, castling rights, and  */
/* possibly an en passant square. we use a square centric approach to store  */
/* the placement of pieces because it is easy to implement, and being able   */
/* to quickly look up what piece is on any given square is useful for move   */
/* generation.                                                               */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: bitboards                                           */
/* bitboards provide a way to store the placement of pieces on a chess board */
/* using 64 bit integers where every bit represents a square on the board.   */
/* you might have a bitboard for each piece type and color, and then use     */
/* bitwise operations for move generation. this is more efficient than a     */
/* square centric approach, but it is also more complicated to implement.    */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: draw detection                                      */
/* to keep the code simple we do not detect draws. to implement draw         */
/* detection you need to store the number of reversible moves to keep track  */
/* of the fifty move rule, as well as a history of board states to detect    */
/* threefold repetition.                                                     */
/*                                                                           */
/* https://www.chessprogramming.org/Board_Representation                     */
/* https://www.chessprogramming.org/Bitboards                                */
struct position {
	/* pieces indexed by square. `NO_PIECE` is used for empty squares.       */
	int board[64];

	/* color of the current side to move, must be `WHITE` or `BLACK`.        */
	int side_to_move;

	/* castling rights indexed by piece color.                               */
	int castling_rights[2];

	/* en passant square, may be `NO_SQUARE`.                                */
	int en_passant_square;

	/* One bitboard for each piece											 */
	Bitboard bitboards[2][6];
};

/* print out information about the position. useful for debugging.           */
void print_position(const struct position *pos, FILE *stream);

/* parse a FEN string and store the result in `pos`. returns `SUCCESS` on    */
/* success, `FAILURE` on failure.                                            */
/*                                                                           */
/* https://www.chessprogramming.org/Forsyth-Edwards_Notation                 */
int parse_position(struct position *pos, const char *fen);

#endif

================
File: includes/score.h
================
#ifndef SCORE_H
#define SCORE_H

#define DOUBLE_PAWN_BONUS 25
#define ISOLATED_PAWN_BONUS 20
#define PASSED_PAWN_BONUS 40
#define ROOK_OPEN_FILE_BONUS 25
#define ROOK_SEMI_OPEN_FILE_BONUS 10

#endif

================
File: includes/search.h
================
#ifndef SEARCH_H
#define SEARCH_H

#include "position.h"
#include "move.h"
#include "uci.h"
#define	TABLE_MAX	1000000


/* information passed to the search function.                                */
struct search_info {
	/* a pointer to the position.                                            */
	const struct position *pos;

	/* time in milliseconds for both players.                                */
	int time[2];

	/* increment in milliseconds for both players.                           */
	int increment[2];
};

/* the return type of `minimax`                                              */
struct search_result {
	/* the best move found for the position passed to `minimax`.             */
	struct move move;

	/* the score of the position passed to `minimax`.                        */
	int score;
};

/*transposition table struct which stores all results*/
typedef struct s_table
{
	__uint64_t	hash;
	int			score;
	int			depth;
	struct move	best_move;
}	t_table;



/* in essence, `minimax` is just another evaluation function. it looks some  */
/* number of moves into the future and returns the value of the best         */
/* position we can reach, assuming our opponent is trying to give us a worse */
/* position. the number of number of moves we look into the future is called */
/* the search depth. at depth 1, we have full control over the position, so  */
/* the value of this position is the maximum of the values of all positions  */
/* after one move. at depth 2, we also consider that our opponent will get   */
/* to make a move, and they will always pick the move that is worst for us,  */
/* so the value of a position after we make a move is the minimum of the     */
/* values of all positions after our opponent also moves. and the final      */
/* value of this position is the maximum of those values. this recursive     */
/* alternating minimizing and maximizing is where minimax gets its name      */
/* from. this function returns both the best move and the value of the       */
/* position.                                                                 */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: alpha-beta pruning                                  */
/* our naive minimax function wastes a lot of time calculating moves for one */
/* player, after we have already found a move that is so bad for the other   */
/* player that they would never want to enter this position anyways. for     */
/* example, if we are trying to determine the value of a queen move, and we  */
/* find the move results in a position where the opponent can forcibly       */
/* capture the queen, there is no point in calculating the rest of the       */
/* possible outcomes after we move the queen. once we find that the opponent */
/* can force us into a position that is worse than one we already have for a */
/* different move, we can stop calculating this branch of the search tree.   */
/* alpha-beta pruning accomplishes this by keeping track of two values,      */
/* alpha, and beta. alpha is the minimum score that we can surely reach no   */
/* no matter what our opponent does, and beta is the maximum score that our  */
/* opponent can surely reach no matter what we do. when a move is found with */
/* a score that falls outside of these bounds, we can stop searching this    */
/* position, because one of the players is sure to play something else for   */
/* one of the moves leading up to this position.                             */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: move ordering                                       */
/* with alpha-beta pruning implemented, there are suddenly big performance   */
/* improvements to be had by searching first moves that are likely to be     */
/* good. why? remember, alpha-beta pruning works by stopping the search of a */
/* position when a move is found that is so bad for one player that they     */
/* will surely play something else for one of the moves leading up to this   */
/* position. so, we want to try these moves that are likely to cause cutoffs */
/* as soon as possible, so that we might be able to avoid searching the rest */
/* of the moves. the move ordering key is a sort of mini evaluation function */
/* for moves instead of positions. captures, promotions, and checks, are     */
/* often ordered before quiet moves. you can also use results from previous  */
/* searches to order moves, if some move was good before, it is likely still */
/* pretty good even if the position is slightly different.                   */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: transposition table                                 */
/* in chess, transposition is the act of transitioning from one position     */
/* into another position. most positions can be transposed into in multiple  */
/* ways. for example, 1. e4 e5 2. Nc3 gives the same position as             */
/* 1. Nc3 e5 2. e4. as there are two ways to reach this position, our naive  */
/* minimax implementation would end up evaluating it twice. implement a hash */
/* table to quickly check if a position has been seen before, and if so,     */
/* just take the result from a previous search. special care must be taken   */
/* when this is combined with alpha-beta pruning, as the values for alpha    */
/* and beta may be different from what they were when the position was first */
/* searched. also note that your program has limited memory, so you must     */
/* develop a strategy to replace old entries with ones that are more likely  */
/* to be useful when you run out of space. see the wiki for more info.       */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: quiescence search                                   */
/* our naive minimax implementation searches every move to the same depth.   */
/* in practice, it is often better to spend some extra time after the main   */
/* search depth has been reached to check if there are any moves that could  */
/* have a big impact on the evaluation, and might result in an inaccurate    */
/* evaluation if left unresolved. for example if, at the end of our search   */
/* depth, we reach a position where one player could capture a piece and the */
/* capturing piece could not be recaptured, then the other player is very    */
/* likely to lose that piece, and it would be inaccurate to evaluate the     */
/* position with the piece still on the board. quiescence search extends the */
/* search after the depth has reached zero, but only considers impactful     */
/* moves such as captures. when there are no such moves left, the normal     */
/* evaluation function is called. quiescence search works best when you have */
/* a special move generator that only generates impactful moves and doesn't  */
/* waste any time generating quiet moves.                                    */
/*                                                                           */
/* https://www.chessprogramming.org/Minimax                                  */
/* https://www.chessprogramming.org/Alpha-Beta                               */
/* https://www.chessprogramming.org/Move_Ordering                            */
/* https://www.chessprogramming.org/Transposition_Table                      */
/* https://www.chessprogramming.org/Quiescence_Search                        */
struct search_result minimax(const struct position *pos, int depth, int alpha, int beta);

/* the search function sets up the search parameters and calls `minimax` to  */
/* starts searching. our basic implementation always starts a search at a    */
/* fixed depth of 4.                                                         */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: time management                                     */
/* instead of always searching to a fixed depth, come up with a better       */
/* strategy to effectively use your time. for example, when you are low on   */
/* time you might want to search to a shallower depth.                       */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: iterative deepening                                 */
/* even if you know how much time you want to spend calculating your next    */
/* move, how do you decide what depth to search at so that the search        */
/* completes within the given time? the time it takes to search to a given   */
/* depth depends on the number of legal moves in the position, the speed of  */
/* the system the engine is running on, and other things. instead of trying  */
/* to guess a good depth, you can start with some low depth, such as 2, and  */
/* incrementally search higher depths when there is still time left. this    */
/* might seem like it wastes a lot of time searching lower depths only to    */
/* discard the result after searching a higher depth, but in practice this   */
/* time is insignificant, because a search at even one depth higher takes an */
/* order of magnitude longer to complete than all lower depths before it.    */
/*                                                                           */
/* POSSIBLE IMPROVEMENT: opening book                                        */
/* a deterministic chess engine will always output the same move when given  */
/* the same position. so instead of wasting time calculating the best move   */
/* in the starting position, you can instead precalculate the best move and  */
/* return it immediately. you can also precalculate moves for common         */
/* openings (for example, what to do after 1. e4 e5?), and endgames.         */
/*                                                                           */
/* https://www.chessprogramming.org/Search                                   */
/* https://www.chessprogramming.org/Time_Management                          */
/* https://www.chessprogramming.org/Iterative_Deepening                      */
/* https://www.chessprogramming.org/Opening_Book                             */
struct move search(const struct search_info *info);

#endif

================
File: includes/types.h
================
#ifndef TYPES_H
#define TYPES_H

#include <stdint.h>

typedef uint64_t Bitboard;

#define SUCCESS 0
#define FAILURE -1

#define NO_COLOR -1
#define NO_PROMOTION -1
#define NO_TYPE -1
#define NO_PIECE -1
#define NO_FILE -1
#define NO_RANK -1
#define NO_SQUARE -1

#define FILE_A 0
#define FILE_B 1
#define FILE_C 2
#define FILE_D 3
#define FILE_E 4
#define FILE_F 5
#define FILE_G 6
#define FILE_H 7

#define RANK_1 0
#define RANK_2 1
#define RANK_3 2
#define RANK_4 3
#define RANK_5 4
#define RANK_6 5
#define RANK_7 6
#define RANK_8 7

#define WHITE 0
#define BLACK 1

#define PAWN 0
#define KNIGHT 1
#define BISHOP 2
#define ROOK 3
#define QUEEN 4
#define KING 5

#define KING_SIDE 1
#define QUEEN_SIDE 2

/* returns the square with the given file and rank.                          */
#define SQUARE(file, rank) ((rank) * 8 + (file))

/* returns the file of the given square.                                     */
#define FILE(square) ((square) % 8)

/* returns the rank of the given square.                                     */
#define RANK(square) ((square) / 8)

/* returns the piece with the given color and type.                          */
#define PIECE(color, type) ((type) * 2 + (color))

/* returns the color of the given piece.                                     */
#define COLOR(piece) ((piece) % 2)

/* returns the type of the given piece.                                      */
#define TYPE(piece) ((piece) / 2)

/* returns the rank from the perspective of the given color.                 */
#define RELATIVE(rank, color) ((color) == WHITE ? (rank) : 7 - (rank))

#endif

================
File: includes/uci.h
================
#ifndef UCI_H
#define UCI_H

/* Universal Chess Interface is a protocol that chess GUIs use to talk to    */
/* chess engines. this function is called from `main` and handles            */
/* communication with the GUI. it's all just boring text parsing stuff, so   */
/* i'll spare you the details. do note that we only implement the bare       */
/* minimum required to play a game of chess, other stuff like pondering and  */
/* search options are not implemented.                                       */
/*                                                                           */
/* https://www.chessprogramming.org/UCI                                      */

#include "stdint.h"

extern __uint64_t	z_table[64][12];

__uint64_t get_random64();
void	init_z_hash();
void uci_run(const char *name, const char *author);

#endif

================
File: src/evaluate/endgame.c
================
#include "bitboards.h"
#include "position.h"
#include "types.h"
#include "evaluate.h"
#include <math.h>
#include <stdlib.h>

int evaluate_king_corner_endgame(const struct position *pos, float game_phase)
{
	float endgame_weight = 1.0f - game_phase;

	// Get king squares
	int friendly_king_sq = get_lsb(pos->bitboards[pos->side_to_move][KING]);
	int opponent_king_sq = get_lsb(pos->bitboards[!pos->side_to_move][KING]);

	int score = 0;

	// Get coordinates for opponent king
	int opponent_king_file = opponent_king_sq % 8;
	int opponent_king_rank = opponent_king_sq / 8;

	// Calculate opponent king's distance from center
	int opponent_dist_to_center_file = MAX(3 - opponent_king_file, opponent_king_file - 4);
	int opponent_dist_to_center_rank = MAX(3 - opponent_king_rank, opponent_king_rank - 4);
	int opponent_dist_from_center = opponent_dist_to_center_file + opponent_dist_to_center_rank;

	// Reward pushing opponent king away from center
	score += opponent_dist_from_center;

	// Get coordinates for friendly king
	int friendly_king_file = friendly_king_sq % 8;
	int friendly_king_rank = friendly_king_sq / 8;

	// Calculate distance between kings
	int file_distance = abs(friendly_king_file - opponent_king_file);
	int rank_distance = abs(friendly_king_rank - opponent_king_rank);
	int kings_distance = file_distance + rank_distance;

	// Reward keeping our king close to opponent king
	score += 14 - kings_distance;

	// Apply endgame weight and scaling factor
	return (int)(score * 10 * endgame_weight);
}

================
File: src/evaluate/evaluate.c
================
#include "evaluate.h"
#include "types.h"

const int piece_value[6] = { 100, 320, 330, 500, 900, 20000 };

int evaluate(const struct position *pos)
{
	int score[2] = { 0, 0 };
	int square;
	int game_phase = get_game_phase(pos);

	for (square = 0; square < 64; square++)
	{
		int piece = pos->board[square];

		if (piece != NO_PIECE)
		{
			int color = COLOR(piece);
			int type = TYPE(piece);

			// Material value
			score[color] += piece_value[type];

			// Piece square table value
			score[color] += get_piece_square_value(piece, square, game_phase);
		}
	}
	int positional_score = 0;
	int end_game_score = 0;

	positional_score += evaluate_pawn_structure(pos);
	positional_score += evaluate_rook(pos);

	end_game_score += evaluate_king_corner_endgame(pos, game_phase);
	int final_score = (score[WHITE] - score[BLACK]) + positional_score + end_game_score;
	return (pos->side_to_move == WHITE) ? final_score : -final_score;
}

================
File: src/evaluate/game_phase.c
================
#include "position.h"
#include "types.h"

float get_game_phase(const struct position *pos)
{
	const int TOTAL_PHASE = 256;
	const int KNIGHT_PHASE = 16;
	const int BISHOP_PHASE = 16;
	const int ROOK_PHASE = 32;
	const int QUEEN_PHASE = 64;

	int phase = 0; // Start from 0 instead of TOTAL_PHASE

	// Add phase value for each piece present
	phase += KNIGHT_PHASE * __builtin_popcountll(pos->bitboards[WHITE][KNIGHT] | pos->bitboards[BLACK][KNIGHT]);
	phase += BISHOP_PHASE * __builtin_popcountll(pos->bitboards[WHITE][BISHOP] | pos->bitboards[BLACK][BISHOP]);
	phase += ROOK_PHASE * __builtin_popcountll(pos->bitboards[WHITE][ROOK] | pos->bitboards[BLACK][ROOK]);
	phase += QUEEN_PHASE * __builtin_popcountll(pos->bitboards[WHITE][QUEEN] | pos->bitboards[BLACK][QUEEN]);

	return (float)phase / TOTAL_PHASE;
}

================
File: src/evaluate/pawn_structure.c
================
#include <position.h>
#include <types.h>
#include "score.h"

int evaluate_pawn_structure(const struct position *pos)
{
	int score = 0;
	Bitboard white_pawns = pos->bitboards[WHITE][PAWN];
	Bitboard black_pawns = pos->bitboards[BLACK][PAWN];

	// Pre-compute full mask for shifting
	Bitboard column = 0x0101010101010101ULL;

	for (int file = 0; file < 8; file++)
	{
		Bitboard file_mask = column << file;

		// Doubled pawns
		int white_count = __builtin_popcountll(white_pawns & file_mask);
		int black_count = __builtin_popcountll(black_pawns & file_mask);

		if (white_count > 1)
			score -= DOUBLE_PAWN_BONUS * (white_count - 1);
		if (black_count > 1)
			score += DOUBLE_PAWN_BONUS * (black_count - 1);

		// Isolated pawns
		Bitboard adjacent = 0;
		if (file > 0) adjacent |= column << (file - 1);
		if (file < 7) adjacent |= column << (file + 1);

		if ((white_pawns & file_mask) && !(white_pawns & adjacent))
			score -= ISOLATED_PAWN_BONUS;
		if ((black_pawns & file_mask) && !(black_pawns & adjacent))
			score += ISOLATED_PAWN_BONUS;

		// Passed pawns
		Bitboard white_file_pawns = white_pawns & file_mask;
		Bitboard black_file_pawns = black_pawns & file_mask;

		while (white_file_pawns)
		{
			int pawn_square = __builtin_ctzll(white_file_pawns);
			int rank = pawn_square / 8;

			// Create a mask for all squares in front of the pawn in this and adjacent files
			Bitboard front_mask = file_mask;
			if (file > 0) front_mask |= (column << (file - 1));
			if (file < 7) front_mask |= (column << (file + 1));

			// Mask only squares in front of the pawn
			front_mask &= ~((1ULL << (rank * 8 + 8)) - 1);

			// If no black pawns in front, it's passed
			if (!(black_pawns & front_mask))
				score += PASSED_PAWN_BONUS;

			white_file_pawns &= (white_file_pawns - 1);
		}

		// Same for black pawns
		while (black_file_pawns)
		{
			int pawn_square = __builtin_ctzll(black_file_pawns);
			int rank = pawn_square / 8;

			Bitboard front_mask = file_mask;
			if (file > 0) front_mask |= (column << (file - 1));
			if (file < 7) front_mask |= (column << (file + 1));

			front_mask &= ((1ULL << (rank * 8)) - 1);

			if (!(white_pawns & front_mask))
				score -= PASSED_PAWN_BONUS;

			black_file_pawns &= (black_file_pawns - 1);
		}

	}
	return score;
}

================
File: src/evaluate/piece_square_value.c
================
#include "types.h"
#include "evaluate.h"
#include "piece_square_value.h"

int get_piece_square_value(int piece, int square, float phase_pct)
{
	int type = TYPE(piece);
	int color = COLOR(piece);
	int sq = (color == WHITE) ? 63 - square : square;

	switch (type)
	{
		case PAWN:
		{
			int mg_value = pawn_position_start[sq];
			int eg_value = pawn_position_end[sq];
			// mg stands for middle game
			// eg stands for end game
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		case KNIGHT:
		{
			int mg_value = knight_position_start[sq];
			int eg_value = knight_position_end[sq];
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		case BISHOP:
		{
			int mg_value = bishop_position_start[sq];
			int eg_value = bishop_position_end[sq];
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		case ROOK:
		{
			int mg_value = rook_position_start[sq];
			int eg_value = rook_position_end[sq];
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		case QUEEN:
		{
			int mg_value = queen_position_start[sq];
			int eg_value = queen_position_end[sq];
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		case KING:
		{
			int mg_value = king_position_start[sq];
			int eg_value = king_position_end[sq];
			return (int)(mg_value * phase_pct + eg_value * (1.0f - phase_pct));
		}
		default:
			return 0;
	}
}

================
File: src/evaluate/rook.c
================
#include <stdbool.h>

#include "bitboards.h"
#include "position.h"
#include "types.h"
#include "score.h"

int evaluate_rook(const struct position *pos)
{
	int score = 0;
	Bitboard white_pawns = pos->bitboards[WHITE][PAWN];
	Bitboard black_pawns = pos->bitboards[BLACK][PAWN];

	Bitboard column = 0x0101010101010101ULL;

	Bitboard white_rooks = pos->bitboards[WHITE][ROOK];
	Bitboard black_rooks = pos->bitboards[BLACK][ROOK];

	for (int file = 0; file < 8; file++)
	{
		Bitboard file_mask = column << file;
		bool file_has_white_pawns = (white_pawns & file_mask) != 0;
		bool file_has_black_pawns = (black_pawns & file_mask) != 0;

		// White rooks
		if (white_rooks & file_mask)
		{
			if (!file_has_white_pawns && !file_has_black_pawns)
				score += ROOK_OPEN_FILE_BONUS;
			else if (!file_has_white_pawns)
				score += ROOK_SEMI_OPEN_FILE_BONUS;
		}

		// Black rooks
		if (black_rooks & file_mask)
		{
			if (!file_has_white_pawns && !file_has_black_pawns)
				score -= ROOK_OPEN_FILE_BONUS;
			else if (!file_has_black_pawns)
				score -= ROOK_SEMI_OPEN_FILE_BONUS;
		}
	}
	return score;
}

================
File: src/search/search.c
================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   search.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mschuurm <mschuurm@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 10:01:13 by dsewlia           #+#    #+#             */
/*   Updated: 2025/03/13 18:24:46 by mschuurm         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "search.h"
#include "evaluate.h"
#include "generate.h"
#include "types.h"
#include <limits.h>
#include <stdbool.h>

t_table	table[TABLE_MAX];



// void	init_z_hash()
// {
// 	for (int i = 0; i < 64; i++)
// 	{
// 		for (int j = 0; j < 12; j++)
// 		{
// 			z_table[i][j] = get_random64();
// 		}
// 	}
// }

__uint64_t	get_hash(const struct position *pos)
{
	__uint64_t	hash = 0;
	for (int i = 0; i < 64; i++)
	{
		if (pos->board[i] != NO_PIECE)
		{
			hash ^= z_table[i][pos->board[i]];
		}
	}
	return (hash);
}

__uint64_t update_z_table(__uint64_t hash, int from, int to, int piece, int captured_piece)
{
    hash ^= z_table[from][piece];
    if (captured_piece != NO_PIECE)
        hash ^= z_table[to][captured_piece];
    hash ^= z_table[to][piece];
    return (hash);
}

void	store_results(__uint64_t hash, int score, int depth, struct move best_move)
{
	int	index = hash % TABLE_MAX;
	table[index].hash = hash;
	table[index].score = score;
	table[index].depth = depth;
	table[index].best_move = best_move;
}

bool	get_results(__uint64_t hash, int *prev_score, int depth, struct move *prev_move)
{
	int	index = hash % TABLE_MAX;
	if (table[index].hash == hash && table[index].depth >= depth)
	{
		*prev_score = table[index].score;
		*prev_move = table[index].best_move;
		return (true);
	}
	return (false);
}

struct search_result minimax(const struct position *pos, int depth, int alpha, int beta)
{
	struct search_result result;

	__uint64_t	hash = get_hash(pos);
	struct move	prev_move;
	int			prev_score;
	if (get_results(hash, &prev_score, depth, &prev_move) == true)
	{
		result.score = prev_score;
		result.move = prev_move;
		return (result);
	}
	if (depth == 0) {
		/* we have reached our search depth, so evaluate the position.       */
		result.score = evaluate(pos);
		return (result);
	}
	struct move moves[MAX_MOVES];
	size_t count = generate_legal_moves(pos, moves);
	bool maxi = (depth % 2 == 0);
	result.score = (maxi == true) ? INT_MIN : INT_MAX;

	for (size_t i = 0; i < count; i++)
	{
		struct position copy = *pos;
		int score;
		int	piece = pos->board[moves[i].from_square];
		/* do a move, the current player in `copy` is then the opponent, */
		/* and so when we call minimax we get the score of the opponent. */
		do_move(&copy, moves[i]);
		int captured_piece = pos->board[moves[i].to_square];
		update_z_table(hash, moves[i].from_square, moves[i].to_square, piece, captured_piece); 
		/* minimax is called recursively. this call returns the score of */
		/* the opponent, so we must negate it to get our score.          */
		score = minimax(&copy, depth - 1, alpha, beta).score;
		/* update the best move if we found a better one.                */
		if (maxi)
		{
			if (score > result.score)
			{
				result.score = score;
				result.move = moves[i];
			}
			alpha = (score > alpha) ? score : alpha;
		}
		else
		{
			if (score < result.score)
			{
				result.score = score;
				result.move = moves[i];
			}
			beta = (score < beta) ? score : beta;
		}
		if (alpha >= beta)
			break ;
	}
	store_results(hash, result.score, depth, result.move);
	return result;
}

struct move search(const struct search_info *info)
{
	return minimax(info->pos, 6, INT_MIN, INT_MAX).move;
}

================
File: src/bitboards.c
================
#include "types.h"
#include "position.h"
#include "move.h"
#include "bitboards.h"
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

static bool is_en_passant(const struct position *pos, struct move move);
static bool is_castling(const struct position *pos, struct move move);

void init_bitboards(struct position *pos)
{
	memset(pos->bitboards, 0, sizeof(pos->bitboards));

	for (int square = 0; square < 64; square++)
	{
		int piece = pos->board[square];
		if (piece != NO_PIECE)
		{
			SET_BIT(pos->bitboards[COLOR(piece)][TYPE(piece)], square);
		}
	}
	printf("Bitboards initialized\n");
}

void update_bitboards_with_move(struct move move, struct position *pos)
{
	int piece_to_move = pos->board[move.from_square];
	int color_piece_to_move = COLOR(piece_to_move);
	int type_piece_to_move = TYPE(piece_to_move);
	int piece_to_capture = pos->board[move.to_square];
	int color_piece_to_capture = COLOR(piece_to_capture);
	int type_piece_to_capture = TYPE(piece_to_capture);

	// Toggle the moving piece's bits: remove from 'from_square', add at 'to_square'
	pos->bitboards[color_piece_to_move][type_piece_to_move] ^= (1ULL << move.from_square) | (1ULL << move.to_square);

	// Handle captures
	if (piece_to_capture != NO_PIECE)
	{
		pos->bitboards[color_piece_to_capture][type_piece_to_capture] ^= (1ULL << move.to_square);
	}

	// Handle promotions
	if (move.promotion_type != NO_PROMOTION)
	{
		// Remove the original piece from the 'to_square' bitboard,
		// then add the promoted piece at 'to_square'
		pos->bitboards[color_piece_to_move][type_piece_to_move] ^= (1ULL << move.to_square);
		int promoted_type = move.promotion_type;
		pos->bitboards[color_piece_to_move][promoted_type] |= (1ULL << move.to_square);
	}

	// Handle en passant
	if (is_en_passant(pos, move))
	{
		int capture_square = (color_piece_to_move == WHITE ? move.to_square - 8 : move.to_square + 8);
		pos->bitboards[color_piece_to_capture][type_piece_to_capture] ^= (1ULL << capture_square);
		pos->board[capture_square] = NO_PIECE;
		printf("En passant\n");
	}

	// Handle castling
	if (is_castling(pos, move))
	{
		// Determine if it’s kingside or queenside by comparing to/from file
		int fromFile = move.from_square % 8;
		int toFile   = move.to_square % 8;
		int rank     = move.from_square / 8;
		bool kingside = (toFile > fromFile);

		// Decide the rook’s source and destination squares
		int rookFromSquare = kingside ? (rank * 8 + 7) : (rank * 8 + 0);
		int rookToSquare   = kingside ? (rank * 8 + 5) : (rank * 8 + 3);

		// Update the board array for the rook
		int rookPiece = pos->board[rookFromSquare];
		pos->board[rookFromSquare] = NO_PIECE;
		pos->board[rookToSquare] = rookPiece;

		// Toggle the rook’s bits in the bitboard
		pos->bitboards[color_piece_to_move][ROOK] ^= (1ULL << rookFromSquare) | (1ULL << rookToSquare);
	}
}

static bool is_en_passant(const struct position *pos, struct move move)
{
	int piece = pos->board[move.from_square];
	if (TYPE(piece) != PAWN)
	{
		return false; // must be a pawn
	}

	// if the 'to_square' square is the en passant square
	if (move.to_square == pos->en_passant_square)
	{
		// and it's a diagonal move
		int fileDistance = abs((move.to_square % 8) - (move.from_square % 8));
		int rankDistance = abs((move.to_square / 8) - (move.from_square / 8));
		if (fileDistance == 1 && rankDistance == 1)
		{
			return true;
		}
	}
	return false;
}

static bool is_castling(const struct position *pos, struct move move)
{
	int piece = pos->board[move.from_square];
	int pieceType = TYPE(piece);

	// Must be the king
	if (pieceType != KING)
	{
		return false;
	}

	// if the 'to_square' square is 2 away from the king’s start
	int fromFile = move.from_square % 8;
	int toFile   = move.to_square % 8;

	if (abs(toFile - fromFile) == 2)
		return true;
	return false;
}

void verify_board_state(const struct position *pos)
{
	for (int square = 0; square < 64; square++) {
		int piece = pos->board[square];
		if (piece != NO_PIECE) {
			int color = COLOR(piece);
			int type = TYPE(piece);

			// Check if the piece is represented in bitboards
			if (!(pos->bitboards[color][type] & (1ULL << square))) {
				printf("Error: Piece on board not in bitboard at square %d\n", square);
			}
		} else {
			// Check no pieces are in bitboards for empty square
			for (int c = 0; c < 2; c++) {
				for (int t = 0; t < 6; t++) {
					if (pos->bitboards[c][t] & (1ULL << square)) {
						printf("Error: Empty square has piece in bitboard at square %d\n", square);
					}
				}
			}
		}
	}
}

================
File: src/generate.c
================
#include "generate.h"
#include "types.h"

/* add the file and rank offset to the square. returns `NO_SQUARE` if the    */
/* resulting square is off the board.                                        */
static int add_offset(int square, int file_offset, int rank_offset)
{
	int file = FILE(square) + file_offset;
	int rank = RANK(square) + rank_offset;

	if (file >= 0 && file < 8 && rank >= 0 && rank < 8)
	{
		return SQUARE(file, rank);
	}
	else
	{
		return NO_SQUARE;
	}
}

/* generate a pawn move, taking into account promotions. returns the number  */
/* of moves generated.                                                       */
static size_t generate_pawn_move(const struct position *pos, struct move *moves, int from_square, int to_square)
{
	size_t count = 0;

	if (RANK(to_square) == RELATIVE(RANK_8, pos->side_to_move)) {
		moves[count++] = make_move(from_square, to_square, KNIGHT);
		moves[count++] = make_move(from_square, to_square, BISHOP);
		moves[count++] = make_move(from_square, to_square, ROOK);
		moves[count++] = make_move(from_square, to_square, QUEEN);
	} else {
		moves[count++] = make_move(from_square, to_square, NO_TYPE);
	}

	return count;
}

/* generate a pawn capture, taking into account promotions. this function    */
/* makes sure that the destination square is on the board, and that it       */
/* contains an opponent piece or is the en passant square. returns the       */
/* number of moves generated.                                                */
static size_t generate_pawn_capture(const struct position *pos, struct move *moves, int from_square, int file_offset, int rank_offset) {
	int to_square = add_offset(from_square, file_offset, rank_offset);

	if (to_square != NO_SQUARE) {
		int piece = pos->board[to_square];
		int capture = piece != NO_PIECE && COLOR(piece) != pos->side_to_move;

		if (capture || to_square == pos->en_passant_square) {
			return generate_pawn_move(pos, moves, from_square, to_square);
		}
	}

	return 0;
}

/* generate a simple, non-sliding move. this function makes sure that the    */
/* destination square is on the board, and that it is empty or contains an   */
/* opponent piece. returns the number of moves generated.                    */
static size_t generate_simple_move(const struct position *pos, struct move *moves, int from_square, int file_offset, int rank_offset)
{
	size_t count = 0;
	int to_square = add_offset(from_square, file_offset, rank_offset);

	if (to_square != NO_SQUARE) {
		int piece = pos->board[to_square];

		if (piece == NO_PIECE || COLOR(piece) != pos->side_to_move) {
			moves[count++] = make_move(from_square, to_square, NO_TYPE);
		}
	}

	return count;
}

/* generate a sliding move. this function keeps adding the offset in a loop  */
/* until the destination square runs off the board or into another piece.    */
/* returns the number of moves generated.                                    */
static size_t generate_sliding_move(const struct position *pos, struct move *moves, int from_square, int file_offset, int rank_offset)
{
	size_t count = 0;
	int to_square = add_offset(from_square, file_offset, rank_offset);

	while (to_square != NO_SQUARE)
	{
		int piece = pos->board[to_square];

		if (piece == NO_PIECE || COLOR(piece) != pos->side_to_move)
		{
			moves[count++] = make_move(from_square, to_square, NO_TYPE);
		}

		if (piece != NO_PIECE)
		{
			break;
		}

		to_square = add_offset(to_square, file_offset, rank_offset);
	}

	return count;
}

size_t generate_pseudo_legal_moves(const struct position *pos, struct move *moves)
{
	size_t count = 0;
	int forward = pos->side_to_move == WHITE ? 1 : -1;
	int square;

	for (square = 0; square < 64; square++)
	{
		int piece = pos->board[square];

		/* skip this square if it is empty or contains an opponent piece.    */
		if (piece == NO_PIECE || COLOR(piece) != pos->side_to_move)
		{
			continue;
		}

		switch (TYPE(piece))
		{
			int up;
			int up_up;

		case PAWN:
			up = add_offset(square, 0, forward);
			up_up = add_offset(square, 0, forward * 2);

			/* pawn push.                                                    */
			if (up != NO_SQUARE && pos->board[up] == NO_PIECE)
			{
				count += generate_pawn_move(pos, moves + count, square, up);

				/* double pawn push.                                         */
				if (up_up != NO_SQUARE && pos->board[up_up] == NO_PIECE)
				{
					if (RANK(square) == RELATIVE(RANK_2, COLOR(piece)))
					{
						count += generate_pawn_move(pos, moves + count, square, up_up);
					}
				}
			}

			/* pawn captures.                                                */
			count += generate_pawn_capture(pos, moves + count, square, -1, forward);
			count += generate_pawn_capture(pos, moves + count, square, 1, forward);

			break;
		case KNIGHT:
			/* knight moves.                                                 */
			count += generate_simple_move(pos, moves + count, square, -1, -2);
			count += generate_simple_move(pos, moves + count, square, 1, -2);
			count += generate_simple_move(pos, moves + count, square, -2, -1);
			count += generate_simple_move(pos, moves + count, square, 2, -1);
			count += generate_simple_move(pos, moves + count, square, -2, 1);
			count += generate_simple_move(pos, moves + count, square, 2, 1);
			count += generate_simple_move(pos, moves + count, square, -1, 2);
			count += generate_simple_move(pos, moves + count, square, 1, 2);

			break;
		case BISHOP:
		case ROOK:
		case QUEEN:
			/* bishop and queen moves.                                       */
			if (TYPE(piece) != ROOK) {
				count += generate_sliding_move(pos, moves + count, square, -1, -1);
				count += generate_sliding_move(pos, moves + count, square, 1, -1);
				count += generate_sliding_move(pos, moves + count, square, -1, 1);
				count += generate_sliding_move(pos, moves + count, square, 1, 1);
			}

			/* rook and queen moves.                                         */
			if (TYPE(piece) != BISHOP) {
				count += generate_sliding_move(pos, moves + count, square, 0, -1);
				count += generate_sliding_move(pos, moves + count, square, -1, 0);
				count += generate_sliding_move(pos, moves + count, square, 1, 0);
				count += generate_sliding_move(pos, moves + count, square, 0, 1);
			}

			break;
		case KING:
			/* simple king moves.                                            */
			count += generate_simple_move(pos, moves + count, square, -1, -1);
			count += generate_simple_move(pos, moves + count, square, 0, -1);
			count += generate_simple_move(pos, moves + count, square, 1, -1);
			count += generate_simple_move(pos, moves + count, square, -1, 0);
			count += generate_simple_move(pos, moves + count, square, 1, 0);
			count += generate_simple_move(pos, moves + count, square, -1, 1);
			count += generate_simple_move(pos, moves + count, square, 0, 1);
			count += generate_simple_move(pos, moves + count, square, 1, 1);

			/* king side castling.                                           */
			if (pos->castling_rights[pos->side_to_move] & KING_SIDE) {
				int f1 = SQUARE(FILE_F, RELATIVE(RANK_1, pos->side_to_move));
				int g1 = SQUARE(FILE_G, RELATIVE(RANK_1, pos->side_to_move));
				int f1_empty = pos->board[f1] == NO_PIECE;
				int g1_empty = pos->board[g1] == NO_PIECE;

				if (f1_empty && g1_empty) {
					moves[count++] = make_move(square, g1, NO_TYPE);
				}
			}

			/* queen side castling.                                          */
			if (pos->castling_rights[pos->side_to_move] & QUEEN_SIDE) {
				int b1 = SQUARE(FILE_B, RELATIVE(RANK_1, pos->side_to_move));
				int c1 = SQUARE(FILE_C, RELATIVE(RANK_1, pos->side_to_move));
				int d1 = SQUARE(FILE_D, RELATIVE(RANK_1, pos->side_to_move));
				int b1_empty = pos->board[b1] == NO_PIECE;
				int c1_empty = pos->board[c1] == NO_PIECE;
				int d1_empty = pos->board[d1] == NO_PIECE;

				if (b1_empty && c1_empty && d1_empty) {
					moves[count++] = make_move(square, c1, NO_TYPE);
				}
			}

			break;
		}
	}

	return count;
}

size_t generate_legal_moves(const struct position *pos, struct move *moves)
{
	size_t pseudo_legal_count = generate_pseudo_legal_moves(pos, moves);
	size_t index;
	size_t count = 0;

	for (index = 0; index < pseudo_legal_count; index++)
	{
		if (is_legal(pos, moves[index]))
		{
			moves[count++] = moves[index];
		}
	}
	return count;
}

================
File: src/main.c
================
#include "perft.h"
#include "uci.h"

#include <stdlib.h>

#define PERFT 0

int main(void)
{
	init_z_hash();

#if PERFT
	perft_run();
#else
	uci_run("the gambit", "mschuurm tridley dsewlia");
#endif

	return EXIT_SUCCESS;
}

================
File: src/move.c
================
#include "move.h"
#include "generate.h"
#include "parse.h"
#include "types.h"
#include "bitboards.h"

struct move make_move(int from_square, int to_square, int promotion_type)
{
	struct move move;

	move.from_square = from_square;
	move.to_square = to_square;
	move.promotion_type = promotion_type;

	return move;
}

int parse_move(struct move *move, const char *string)
{
	/* parse the from square.                                                */
	move->from_square = parse_square(string);

	if (move->from_square == NO_SQUARE)
	{
		return FAILURE;
	}

	/* parse the to square.                                                  */
	move->to_square = parse_square(string + 2);

	if (move->to_square == NO_SQUARE)
	{
		return FAILURE;
	}

	/* parse the promotion type.                                             */
	move->promotion_type = NO_TYPE;

	if (string[4]) {
		move->promotion_type = parse_type(string[4]);

		if (move->promotion_type == NO_TYPE)
		{
			return FAILURE;
		}
	}

	return SUCCESS;
}

void do_move(struct position *pos, struct move move)
{
	int from_file = FILE(move.from_square);
	int from_rank = RANK(move.from_square);
	int to_file = FILE(move.to_square);
	int to_rank = RANK(move.to_square);
	int piece = pos->board[move.from_square];
	int color = pos->side_to_move;
	int a1 = SQUARE(FILE_A, RELATIVE(RANK_1, color));
	int h1 = SQUARE(FILE_H, RELATIVE(RANK_1, color));
	int a8 = SQUARE(FILE_A, RELATIVE(RANK_8, color));
	int h8 = SQUARE(FILE_H, RELATIVE(RANK_8, color));
	int en_passant_square = pos->en_passant_square;

	/* move the piece, promoting it if necessary.                            */
	pos->board[move.from_square] = NO_PIECE;

	if (move.promotion_type != NO_TYPE)
	{
		pos->board[move.to_square] = PIECE(color, move.promotion_type);
	}
	else
	{
		pos->board[move.to_square] = piece;
	}

	/* reset the en passant square.                                          */
	pos->en_passant_square = NO_SQUARE;

	/* update castling rights.                                               */
	if (move.from_square == h1)
	{
		pos->castling_rights[color] &= ~KING_SIDE;
	}
	else if (move.from_square == a1)
	{
		pos->castling_rights[color] &= ~QUEEN_SIDE;
	}

	if (move.to_square == h8)
	{
		pos->castling_rights[1 - color] &= ~KING_SIDE;
	}
	else if (move.to_square == a8)
	{
		pos->castling_rights[1 - color] &= ~QUEEN_SIDE;
	}

	/* update side to move.                                                  */
	pos->side_to_move = 1 - color;

	switch (TYPE(piece))
	{
	case PAWN:
		/* set the en passant square for double pawn pushes.                 */
		if (RELATIVE(to_rank, color) - RELATIVE(from_rank, color) == 2)
		{
			pos->en_passant_square = SQUARE(to_file, RELATIVE(RANK_3, color));
		}

		/* also remove the captured pawn for en passant captures.            */
		if (move.to_square == en_passant_square)
		{
			pos->board[SQUARE(to_file, from_rank)] = NO_PIECE;
		}

		break;

	case KING:
		/* update castling rights for king moves.                            */
		pos->castling_rights[color] = 0;

		/* also move the rook for castling moves.                            */
		if (from_file == FILE_E && to_file == FILE_G)
		{
			pos->board[SQUARE(FILE_H, to_rank)] = NO_PIECE;
			pos->board[SQUARE(FILE_F, to_rank)] = PIECE(color, ROOK);
		}
		else if (from_file == FILE_E && to_file == FILE_C)
		{
			pos->board[SQUARE(FILE_A, to_rank)] = NO_PIECE;
			pos->board[SQUARE(FILE_D, to_rank)] = PIECE(color, ROOK);
		}

		break;
	}
	update_bitboards_with_move(move, pos);
	verify_board_state(pos);
}

int is_legal(const struct position *pos, struct move move)
{
	struct position copy = *pos;
	struct move moves[MAX_MOVES];
	int piece = pos->board[move.from_square];
	size_t count;
	size_t index;

	/* make the move on a copy of the position.                              */
	do_move(&copy, move);

	/* for castling moves, pretend there is another king on all squares      */
	/* between the from square and the to square. this makes it illegal to   */
	/* castle through a square that is controlled by the opponent.           */
	if (TYPE(piece) == KING)
	{
		int from_file = FILE(move.from_square);
		int to_file = FILE(move.to_square);
		int rank = RELATIVE(RANK_1, pos->side_to_move);

		if (from_file == FILE_E && to_file == FILE_G)
		{
			copy.board[SQUARE(FILE_E, rank)] = piece;
			copy.board[SQUARE(FILE_F, rank)] = piece;
		}
		else if (from_file == FILE_E && to_file == FILE_C)
		{
			copy.board[SQUARE(FILE_E, rank)] = piece;
			copy.board[SQUARE(FILE_D, rank)] = piece;
		}
	}

	/* generate all pseudo-legal moves for the opponent.                     */
	count = generate_pseudo_legal_moves(&copy, moves);

	/* return false if any of those moves could capture the king.            */
	for (index = 0; index < count; index++)
	{
		int piece = copy.board[moves[index].to_square];

		if (piece == PIECE(pos->side_to_move, KING))
		{
			return 0;
		}
	}
	/* return true if no moves could capture the king.                       */
	return 1;
}

================
File: src/parse.c
================
#include "parse.h"
#include "types.h"

int parse_file(char c)
{
	switch (c)
	{
		case 'a':
			return FILE_A;

		case 'b':
			return FILE_B;

		case 'c':
			return FILE_C;

		case 'd':
			return FILE_D;

		case 'e':
			return FILE_E;

		case 'f':
			return FILE_F;

		case 'g':
			return FILE_G;

		case 'h':
			return FILE_H;

		default:
			return NO_FILE;
	}
}

int parse_rank(char c)
{
	switch (c)
	{
		case '1':
			return RANK_1;

		case '2':
			return RANK_2;

		case '3':
			return RANK_3;

		case '4':
			return RANK_4;

		case '5':
			return RANK_5;

		case '6':
			return RANK_6;

		case '7':
			return RANK_7;

		case '8':
			return RANK_8;

		default:
			return NO_RANK;
	}
}

int parse_square(const char *string)
{
	int file = parse_file(string[0]);

	if (file != NO_FILE) {
		int rank = parse_rank(string[1]);

		if (rank != NO_RANK) {
			return SQUARE(file, rank);
		}
	}
	return NO_SQUARE;
}

int parse_color(char c)
{
	switch (c)
	{
		case 'w':
			return WHITE;

		case 'b':
			return BLACK;

		default:
			return NO_COLOR;
	}
}

int parse_type(char c)
{
	switch (c)
	{
		case 'p':
			return PAWN;

		case 'n':
			return KNIGHT;

		case 'b':
			return BISHOP;

		case 'r':
			return ROOK;

		case 'q':
			return QUEEN;

		case 'k':
			return KING;

		default:
			return NO_TYPE;
	}
}

int parse_piece(char c)
{
	switch (c)
	{
		case 'P':
			return PIECE(WHITE, PAWN);

		case 'N':
			return PIECE(WHITE, KNIGHT);

		case 'B':
			return PIECE(WHITE, BISHOP);

		case 'R':
			return PIECE(WHITE, ROOK);

		case 'Q':
			return PIECE(WHITE, QUEEN);

		case 'K':
			return PIECE(WHITE, KING);

		case 'p':
			return PIECE(BLACK, PAWN);

		case 'n':
			return PIECE(BLACK, KNIGHT);

		case 'b':
			return PIECE(BLACK, BISHOP);

		case 'r':
			return PIECE(BLACK, ROOK);

		case 'q':
			return PIECE(BLACK, QUEEN);

		case 'k':
			return PIECE(BLACK, KING);

		default:
			return NO_PIECE;
	}
}

================
File: src/perft.c
================
#include "perft.h"

#include <bitboards.h>

#include "generate.h"
#include "position.h"
#include "types.h"

#include <stddef.h>

struct perft_data
{
	const char *fen;
	int depth;
	unsigned long nodes;
};

/* https://www.chessprogramming.org/Perft_Results                            */
static const struct perft_data perft_data[] = {
	{ "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", 6, 119060324 },
	{ "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1", 5, 193690690 },
	{ "8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - - 0 1", 7, 178633661 },
	{ "r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1", 6, 706045033 },
	{ "r2q1rk1/pP1p2pp/Q4n2/bbp1p3/Np6/1B3NBn/pPPP1PPP/R3K2R b KQ - 0 1", 6, 706045033 },
	{ "rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8", 5, 89941194 },
	{ "r4rk1/1pp1qppp/p1np1n2/2b1p1B1/2B1P1b1/P1NP1N2/1PP1QPPP/R4RK1 w - - 0 10", 5, 164075551 },
};

static unsigned long perft(const struct position *pos, int depth)
{
	struct move moves[MAX_MOVES];
	size_t count = generate_legal_moves(pos, moves);

	if (depth == 0)
	{
		return 1;
	}
	else if (depth == 1)
	{
		return count;
	}
	else
	{
		size_t index;
		unsigned long result = 0;

		for (index = 0; index < count; index++)
		{
			struct position copy = *pos;

			do_move(&copy, moves[index]);

			result += perft(&copy, depth - 1);
		}
		return result;
	}
}

void perft_run(void)
{
	int count = sizeof perft_data / sizeof *perft_data;
	int index;
	int passed = 0;

	for (index = 0; index < count; index++)
	{
		struct perft_data data = perft_data[index];
		struct position pos;
		unsigned long nodes;

		if (parse_position(&pos, data.fen) != SUCCESS)
		{
			fprintf(stderr, "test %02d, parse error\n", index);

			continue;
		}
		init_bitboards(&pos);
		nodes = perft(&pos, data.depth);

		if (nodes != data.nodes)
		{
			fprintf(stderr, "test %02d, %lu nodes, expected %lu\n", index, nodes, data.nodes);
		}
		else
		{
			fprintf(stderr, "test %02d, %lu nodes\n", index, nodes);

			passed++;
		}
	}

	fprintf(stderr, "%d/%d tests passed\n", passed, count);
}

================
File: src/position.c
================
#include "position.h"

#include <bitboards.h>

#include "parse.h"
#include "types.h"

void print_position(const struct position *pos, FILE *stream)
{
	char castling_rights_buffer[] = { '-', '\0', '\0', '\0', '\0' };
	char en_passant_square_buffer[] = { '-', '\0', '\0' };
	char *castling_rights = castling_rights_buffer;
	char *en_passant_square = en_passant_square_buffer;
	int file;
	int rank;

	/* print piece placement.                                                */
	fprintf(stream, "  a b c d e f g h  \n");

	for (rank = 7; rank >= 0; rank--)
	{
		fprintf(stream, "%c", '1' + rank);

		for (file = 0; file < 8; file++)
		{
			int piece = pos->board[SQUARE(file, rank)];

			if (piece == NO_PIECE)
				fprintf(stream, " -");
			else
				fprintf(stream, " %c", "PpNnBbRrQqKk"[piece]);
		}
		fprintf(stream, " %c\n", '1' + rank);
	}
	fprintf(stream, "  a b c d e f g h  \n");

	/* stringify castling rights.                                            */
	if (pos->castling_rights[WHITE] & KING_SIDE)
		*castling_rights++ = 'K';

	if (pos->castling_rights[WHITE] & QUEEN_SIDE)
		*castling_rights++ = 'Q';

	if (pos->castling_rights[BLACK] & KING_SIDE)
		*castling_rights++ = 'k';

	if (pos->castling_rights[BLACK] & QUEEN_SIDE)
		*castling_rights++ = 'q';

	/* stringify en passant square.                                          */
	if (pos->en_passant_square != NO_SQUARE)
	{
		*en_passant_square++ = "abcdefgh"[FILE(pos->en_passant_square)];
		*en_passant_square++ = '1' + RANK(pos->en_passant_square);
	}

	/* print other information.                                              */
	fprintf(stream, "side to move: %c\n", "wb"[pos->side_to_move]);
	fprintf(stream, "castling rights: %s\n", castling_rights_buffer);
	fprintf(stream, "en passant square: %s\n", en_passant_square_buffer);
}

int parse_position(struct position *pos, const char *fen)
{
	int file;
	int rank;
	int square;
	int index;

	/* initialize an empty board.                                            */
	for (square = 0; square < 64; square++)
		pos->board[square] = NO_PIECE;

	/* parse piece placement.                                                */
	for (file = 0, rank = 7; file < 8 || rank > 0; fen++)
	{
		int piece = parse_piece(*fen);

		if (piece != NO_PIECE)
		{
			if (file >= 8)
				return FAILURE;

			pos->board[SQUARE(file, rank)] = piece;
			file++;
		}
		else if (*fen >= '1' && *fen <= '8')
		{
			file += *fen - '0';

			if (file > 8)
				return FAILURE;
		}
		else if (*fen == '/')
		{
			if (file != 8)
				return FAILURE;
			file = 0;
			rank--;
		}
		else
			return FAILURE;
	}
	if (*fen++ != ' ')
		return FAILURE;

	/* parse side to move.                                                   */
	pos->side_to_move = parse_color(*fen++);

	if (pos->side_to_move == NO_COLOR)
		return FAILURE;

	if (*fen++ != ' ')
		return FAILURE;

	/* parse castling rights.                                                */
	pos->castling_rights[WHITE] = 0;
	pos->castling_rights[BLACK] = 0;

	if (*fen == '-')
		fen++;
	else
	{
		const char *start = fen;

		if (*fen == 'K')
		{
			pos->castling_rights[WHITE] |= KING_SIDE;
			fen++;
		}

		if (*fen == 'Q')
		{
			pos->castling_rights[WHITE] |= QUEEN_SIDE;
			fen++;
		}

		if (*fen == 'k')
		{
			pos->castling_rights[BLACK] |= KING_SIDE;
			fen++;
		}

		if (*fen == 'q')
		{
			pos->castling_rights[BLACK] |= QUEEN_SIDE;
			fen++;
		}

		if (fen == start)
			return FAILURE;
	}

	if (*fen++ != ' ')
		return FAILURE;

	/* parse en passant square.                                              */
	pos->en_passant_square = parse_square(fen);

	if (*fen == '-')
		fen += 1;
	else if (pos->en_passant_square != NO_SQUARE)
		fen += 2;
	else
		return FAILURE;

	/* ignore halfmove clock and fullmove counter.                           */
	for (index = 0; index < 2; index++)
	{
		if (*fen++ != ' ')
			return FAILURE;
		if (*fen < '0' || *fen > '9')
			return FAILURE;
		while (*fen >= '0' && *fen <= '9')
			fen++;
	}

	/* make sure we reached the end of the string.                           */
	if (*fen)
		return FAILURE;
	return (SUCCESS);
}

================
File: src/uci.c
================
#include "uci.h"
#include "search.h"
#include "move.h"
#include "types.h"
#include "bitboards.h"

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

uint64_t z_table[64][12];

static char *get_line(FILE *stream)
{
	size_t capacity = 1024;
	size_t size = 0;
	char *string = malloc(capacity);

	while (fgets(string + size, capacity - size, stream))
	{
		size += strlen(string + size);

		if (string[size - 1] == '\n')
			return string;

		capacity *= 2;
		string = realloc(string, capacity);
	}

	free(string);

	return NULL;
}

static char *get_token(char *string, char *store)
{
	string += strlen(string);
	*string = *store;

	while (isspace(*string))
		string++;

	if (*string)
	{
		char *token = string;

		while (*string && !isspace(*string))
			string++;
		*store = *string;
		*string = '\0';

		return token;
	}
	return NULL;
}

void print_pos(struct position *pos) {
	for (int y = 0; y < 8; y++) {
		for (int x = 0; x < 8; x++) {
			int p = pos->board[y * 8 + x];
			if (p == NO_PIECE) {
				printf(". ");
				continue;
			}
			char c;
			switch (TYPE(p)) {
				case PAWN: c = 'p'; break;
				case KNIGHT: c = 'n'; break;
				case BISHOP: c = 'b'; break;
				case ROOK: c = 'r'; break;
				case QUEEN: c = 'q'; break;
				case KING: c = 'k'; break;
			}
			if (COLOR(p) == WHITE) {
				c = toupper(c);
			}
			printf("%c ", c);
		}
		printf("\n");
	}
}

static void uci_position(struct position *pos, char *token, char *store)
{
	token = get_token(token, store);

	if (token && !strcmp(token, "startpos"))
	{
		parse_position(pos, "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
		init_bitboards(pos);
		token = get_token(token, store);
	}
	else if (token && !strcmp(token, "fen"))
	{
		char *fen = get_token(token, store);
		int index;

		token = fen;

		for (index = 0; token && index < 5; index++)
			token = get_token(token, store);

		if (token)
		{
			parse_position(pos, fen);
			init_bitboards(pos);
			token = get_token(token, store);
		}
	}
	if (token && !strcmp(token, "moves"))
	{
		while ((token = get_token(token, store)))
		{
			struct move move;

			if (parse_move(&move, token) == SUCCESS)
			{
				do_move(pos, move);
				update_bitboards_with_move(move, pos);
			}
		}
	}
}

__uint64_t get_random64()
{
	return ((__uint64_t)rand() << 32 | ((__uint64_t)rand()));
}

void	init_z_hash()
{
	for (int i = 0; i < 64; i++)
	{
		for (int j = 0; j < 12; j++)
		{
			z_table[i][j] = get_random64();
		}
	}
}

static void uci_go(const struct position *pos, char *token, char *store)
{
	struct search_info info;
	struct move move;
	char buffer[] = { '\0', '\0', '\0', '\0', '\0', '\0' };

	info.pos = pos;
	info.time[WHITE] = 0;
	info.time[BLACK] = 0;
	info.increment[WHITE] = 0;
	info.increment[BLACK] = 0;

	// init_z_hash();
	while ((token = get_token(token, store)))
		{
		if (!strcmp(token, "searchmoves"))
		{
			break;
		}
		else if (!strcmp(token, "ponder"))
		{
			continue;
		}
		else if (!strcmp(token, "infinite"))
		{
			continue;
		}
		else if (!strcmp(token, "wtime"))
		{
			token = get_token(token, store);
			info.time[WHITE] = token ? atoi(token) : 0;
		}
		else if (!strcmp(token, "btime"))
		{
			token = get_token(token, store);
			info.time[BLACK] = token ? atoi(token) : 0;
		}
		else if (!strcmp(token, "winc"))
		{
			token = get_token(token, store);
			info.increment[WHITE] = token ? atoi(token) : 0;
		}
		else if (!strcmp(token, "binc"))
		{
			token = get_token(token, store);
			info.increment[BLACK] = token ? atoi(token) : 0;
		}
		else
		{
			token = get_token(token, store);
		}

		if (!token)
		{
			break;
		}
	}

	move = search(&info);

	buffer[0] = "abcdefgh"[FILE(move.from_square)];
	buffer[1] = '1' + RANK(move.from_square);
	buffer[2] = "abcdefgh"[FILE(move.to_square)];
	buffer[3] = '1' + RANK(move.to_square);

	if (move.promotion_type != NO_TYPE) {
		buffer[4] = "pnbrqk"[move.promotion_type];
	}

	printf("bestmove %s\n", buffer);
}

void uci_run(const char *name, const char *author)
{
	char *line;
	int quit = 0;
	struct position pos;

	while (!quit && (line = get_line(stdin)))
	{
		char *token = line;
		char store = *token;

		*token = '\0';

		while ((token = get_token(token, &store)))
		{
			if (!strcmp(token, "quit"))
			{
				quit = 1;
			}
			else if (!strcmp(token, "uci"))
			{
				printf("id name %s\n", name);
				printf("id author %s\n", author);
				printf("uciok\n");
			}
			else if (!strcmp(token, "isready"))
			{
				printf("readyok\n");
			}
			else if (!strcmp(token, "position"))
			{
				uci_position(&pos, token, &store);
			}
			else if (!strcmp(token, "go"))
			{
				uci_go(&pos, token, &store);
			}
			else if (!strcmp(token, "setoption"))
			{
				break;
			}
			else if (!strcmp(token, "register"))
			{
				break;
			}
			else
			{
				continue;
			}
			break;
		}
		free(line);
		fflush(stdout);
	}
}

================
File: Makefile
================
# Executable
NAME = the_gambit

# Flags
COMPILER = cc
CFLAGS = -Wall -Wextra -pedantic -Iincludes
# CFLAGS := -Wall -Wextra -pedantic -std=c89 -O3 -flto -march=native

# Source files
SRC =	src/evaluate/evaluate.c src/evaluate/game_phase.c src/evaluate/piece_square_value.c \
		src/search/search.c src/bitboards.c src/evaluate/pawn_structure.c \
		src/generate.c src/main.c src/move.c src/parse.c src/evaluate/rook.c \
		src/perft.c src/position.c src/uci.c src/evaluate/endgame.c

# Objects
OBJ_DIR = obj
OBJS = $(SRC:%.c=$(OBJ_DIR)/%.o)

# Rules
all: $(NAME)

$(NAME): $(OBJS)
	$(COMPILER) $(CFLAGS) $(OBJS) -o $(NAME)

$(OBJ_DIR)/%.o: %.c
	@mkdir -p $(dir $@)
	$(COMPILER) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJ_DIR)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
